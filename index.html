<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Scrubbable WebM Player with Clickable Frame Links (Wrap-Around)</title>
  <style>
    :root{
      --btn-width: 140px;
      --btn-height: 48px;
      --btn-top: 50%;
      --btn-left: 50%;
      --btn-radius: 10px;
      --snap-duration: 400ms;
      --btn-font-size: 16px;
    }

    html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; background:#111;color:#eee}
    .player-wrap{max-width:1100px;margin:40px auto;padding:10px;}
    .video-container{position:relative;width:100%;aspect-ratio: 16/9;background:#000;overflow:hidden;touch-action:none;-webkit-user-select:none;user-select:none;}
    video{position:absolute;inset:0;width:100%;height:100%;object-fit:contain;display:block;background:#000;}
    .overlay-btn{position:absolute;top:var(--btn-top);left:var(--btn-left);transform:translate(-50%,-50%);width:var(--btn-width);height:var(--btn-height);display:flex;align-items:center;justify-content:center;border-radius:var(--btn-radius);background:rgba(255,255,255,0.08);backdrop-filter:blur(4px);box-shadow:0 6px 18px rgba(0,0,0,0.6);border:1px solid rgba(255,255,255,0.06);color:#fff;cursor:pointer;user-select:none;-webkit-tap-highlight-color:transparent;font-size:var(--btn-font-size);text-decoration:none;}
    .overlay-btn.disabled{opacity:0.45;pointer-events:none}
    .hud{position:absolute;right:8px;bottom:8px;padding:6px 10px;background:rgba(0,0,0,0.5);border-radius:6px;font-size:13px;color:#ddd;}
    .overlay-btn:focus{outline:3px solid rgba(255,255,255,0.12)}
    .info{margin-top:12px;font-size:14px;opacity:0.9}
    @media (max-width:720px){:root{--btn-width:110px;--btn-height:40px;--btn-font-size:14px}}
  </style>
</head>
<body>
  <div class="player-wrap">
    <h2>Scrubbable WebM Player</h2>
    <div id="videoContainer" class="video-container" aria-label="Scrubbable video player">
      <video id="video" preload="metadata" playsinline>
        <source src="video.webm" type="video/webm">
        Your browser does not support the video tag.
      </video>
      <a id="overlayBtn" class="overlay-btn" role="button" href="#" target="_self" aria-label="Open link for current frame">Go</a>
      <div id="hud" class="hud" aria-hidden="true">frame: - | time: -</div>
    </div>
    <p class="info">Drag horizontally to scrub the video (wrap-around). When you release, the player snaps to the nearest link. Click the overlay button to open that link.</p>
  </div>

  <script>
  (function(){
    const video = document.getElementById('video');
    const overlayBtn = document.getElementById('overlayBtn');
    const hud = document.getElementById('hud');
    const container = document.getElementById('videoContainer');

    // ====== CONFIGURATION ======
    const fps = 24; // Frames per second
    const invertMouse = true; // Invert drag direction

    const links = [
      {frame: 20, url: 'https://google.com'},
      {frame: 65, url: 'https://blender.org'},
      {frame: 120, url: 'https://yrgo.com'}
    ];
    const buttonTarget = '_self';
    // ============================

    // ====== INTERNAL STATE ======
    let duration = 0;
    let totalFrames = 0;
    let isDragging = false;
    let startX = 0;
    let startFrame = 0;
    let activeLinkIndex = -1;
    let snapAnimation = null;

    overlayBtn.target = buttonTarget;
    links.sort((a,b)=>a.frame-b.frame);

    // ====== HELPERS ======
    function updateLinkTimes(){ for(const l of links){ l.time = l.frame / fps; } }
    function frameFromTime(t){return Math.round(t * fps);}    
    function timeFromFrame(f){return f / fps;}
    function updateHUD(){const frame = frameFromTime(video.currentTime);hud.textContent = `frame: ${frame} | time: ${video.currentTime.toFixed(2)}s`;}

    // Set active link for current frame
    function setActiveLinkByFrame(frame){
      if(links.length===0){
        activeLinkIndex=-1;
        overlayBtn.classList.add('disabled');
        overlayBtn.href='#';
        return;
      }
      let nearest=0;
      let bestDist=Infinity;
      for(let i=0;i<links.length;i++){
        let dist = Math.abs(frame - links[i].frame);
        // Consider wrap-around distance
        const altDist = Math.abs((frame + totalFrames) - links[i].frame);
        const altDist2 = Math.abs(frame - (links[i].frame + totalFrames));
        dist = Math.min(dist, altDist, altDist2);
        if(dist < bestDist){bestDist = dist; nearest = i;}
      }
      activeLinkIndex=nearest;
      overlayBtn.classList.remove('disabled');
      overlayBtn.href=links[activeLinkIndex].url;
      overlayBtn.setAttribute('data-active-frame', links[activeLinkIndex].frame);
    }

    // Tween video to target time smoothly
    function tweenToTime(targetTime, durationMs){
      if(snapAnimation){cancelAnimationFrame(snapAnimation.raf);snapAnimation=null;}
      const start = video.currentTime;
      const startTs = performance.now();
      function step(now){
        const t = Math.min((now-startTs)/durationMs, 1);
        const eased = 1 - (1-t)*(1-t); // easeOutQuad
        const cur = start + (targetTime - start) * eased;
        video.currentTime = ((cur % duration) + duration) % duration; // Wrap-around
        updateHUD();
        if(t < 1){snapAnimation={raf:requestAnimationFrame(step)};}
        else{snapAnimation=null;setActiveLinkByFrame(frameFromTime(video.currentTime));}
      }
      snapAnimation = {raf: requestAnimationFrame(step)};
    }

    // ====== EVENT HANDLERS ======

    container.addEventListener('pointerdown', (ev)=>{
      if(ev.isPrimary===false) return;
      ev.preventDefault();
      isDragging = true;
      startX = ev.clientX;
      startFrame = frameFromTime(video.currentTime);
      container.setPointerCapture(ev.pointerId);
      if(snapAnimation){cancelAnimationFrame(snapAnimation.raf);snapAnimation=null;}
    });

    container.addEventListener('pointermove', (ev)=>{
      if(!isDragging) return;
      ev.preventDefault();
      const dx = ev.clientX - startX;
      const fraction = (invertMouse ? -dx : dx)/container.clientWidth;
      let frameDelta = Math.round(fraction * totalFrames);
      let newFrame = startFrame + frameDelta;

      // Full wrap-around dragging
      newFrame = ((newFrame % totalFrames) + totalFrames) % totalFrames;

      video.currentTime = timeFromFrame(newFrame);
      updateHUD();
      setActiveLinkByFrame(newFrame);
    });

    container.addEventListener('pointerup', (ev)=>{
      if(!isDragging) return;
      isDragging = false;
      container.releasePointerCapture(ev.pointerId);

      if(links.length===0) return;
      const currentFrame = frameFromTime(video.currentTime);
      let nearestIndex = 0;
      let bestDist = Infinity;

      for(let i=0;i<links.length;i++){
        let dist = Math.abs(currentFrame - links[i].frame);
        const altDist = Math.abs((currentFrame + totalFrames) - links[i].frame);
        const altDist2 = Math.abs(currentFrame - (links[i].frame + totalFrames));
        dist = Math.min(dist, altDist, altDist2);
        if(dist < bestDist){bestDist = dist; nearestIndex = i;}
      }

      const targetTime = links[nearestIndex].time;
      const snapDuration = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--snap-duration')) || 400;
      tweenToTime(targetTime, snapDuration);
    });

    container.addEventListener('pointercancel', ()=>{isDragging=false;});

    // Initialize video and links
    video.addEventListener('loadedmetadata', ()=>{
      duration = video.duration || 0;
      totalFrames = Math.floor(duration * fps);
      updateLinkTimes();
      for(const l of links){if(l.frame<0) l.frame=0; if(l.frame>totalFrames) l.frame=totalFrames;}
      setActiveLinkByFrame(0);
      updateHUD();
    });

    video.addEventListener('timeupdate', ()=>{if(!isDragging&&!snapAnimation) updateHUD();});
    container.addEventListener('contextmenu', (e)=>e.preventDefault());
  })();
  </script>
</body>
</html>
