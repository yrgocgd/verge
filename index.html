<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>GLTF WebGL/WebGPU Viewer</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #toggleButton {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 10px 20px;
            font-size: 16px;
            z-index: 1;
        }
    </style>
</head>
<body>
    <button id="toggleButton">Switch to WebGPU</button>
    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js';
        import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/loaders/GLTFLoader.js';
        import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/controls/OrbitControls.js';
        import { WebGPURenderer } from 'https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/renderers/webgpu/WebGPURenderer.js';

    let scene, camera, controls;
    let webglRenderer, webgpuRenderer, currentRenderer;
    let model;
    let usingWebGPU = false;

    init();
    animate();

    async function init() {
        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1, 3);

        // WebGL Renderer
        webglRenderer = new THREE.WebGLRenderer({ antialias: true });
        webglRenderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(webglRenderer.domElement);

        // WebGPU Renderer
        if (navigator.gpu) {
            webgpuRenderer = new WebGPURenderer({ antialias: true });
            webgpuRenderer.setSize(window.innerWidth, window.innerHeight);
        } else {
            console.warn("WebGPU not supported in this browser.");
        }

        currentRenderer = webglRenderer;

        controls = new OrbitControls(camera, currentRenderer.domElement);
        controls.enableDamping = true;

        // Ambient light
        const ambientLight = new THREE.AmbientLight(0xffffff, 1);
        scene.add(ambientLight);

        // Load model automatically
        const loader = new GLTFLoader();
        loader.load('model.glb', (gltf) => {
            model = gltf.scene;
            scene.add(model);

            // Center model
            const box = new THREE.Box3().setFromObject(model);
            const center = new THREE.Vector3();
            box.getCenter(center);
            model.position.sub(center);

            // Scale model to fill screen
            scaleModelToView(model, box, camera);
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            webglRenderer.setSize(window.innerWidth, window.innerHeight);
            if (webgpuRenderer) webgpuRenderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Toggle button
        const toggleButton = document.getElementById('toggleButton');
        toggleButton.addEventListener('click', () => {
            if (!webgpuRenderer) return;
            usingWebGPU = !usingWebGPU;
            if (usingWebGPU) {
                document.body.replaceChild(webgpuRenderer.domElement, currentRenderer.domElement);
                currentRenderer = webgpuRenderer;
                toggleButton.textContent = "Switch to WebGL";
            } else {
                document.body.replaceChild(webglRenderer.domElement, currentRenderer.domElement);
                currentRenderer = webglRenderer;
                toggleButton.textContent = "Switch to WebGPU";
            }
            controls.domElement = currentRenderer.domElement;
        });
    }

    function scaleModelToView(model, box, camera) {
        const size = new THREE.Vector3();
        box.getSize(size);

        const dist = camera.position.distanceTo(new THREE.Vector3(0, 0, 0));
        const vFOV = THREE.MathUtils.degToRad(camera.fov);
        const heightAtDist = 2 * Math.tan(vFOV / 2) * dist;
        const aspect = window.innerWidth / window.innerHeight;

        const widthScale = heightAtDist * aspect / size.x;
        const heightScale = heightAtDist / size.y;
        const depthScale = heightAtDist / size.z;

        const scale = Math.min(widthScale, heightScale, depthScale);
        model.scale.setScalar(scale);
    }

    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        currentRenderer.render(scene, camera);
    }
</script>

</body>
</html>
